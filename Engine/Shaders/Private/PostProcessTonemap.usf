// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	PostProcessTonemap.usf: PostProcessing tone mapping  
=============================================================================*/

#define EYE_ADAPTATION_LOOSE_PARAMETERS 1

#ifndef SUPPORTS_SCENE_COLOR_APPLY_PARAMETERS
	#define Undefined SUPPORTS_SCENE_COLOR_APPLY_PARAMETERS 0
#endif

#define LOCAL_EXPOSURE_MODE_NONE 0
#define LOCAL_EXPOSURE_MODE_BILATERAL 1
#define LOCAL_EXPOSURE_MODE_FUSION 2


#define TONEMAPPER_MODE 3 //0 Filmic, 1 AGX, 2 GT IctCp, 3 GT JzAzBz
// 0: Default, 1: Golden, 2: Punchy
#define AGX_LOOK 0

#include "Common.ush"
#include "PostProcessCommon.ush"
#include "TonemapCommon.ush"
#include "EyeAdaptationCommon.ush"
#include "PostProcessHistogramCommon.ush"
#include "PixelQuadMessagePassing.ush"
#include "ScreenPass.ush"

#define DEBUG_GRAIN_QUANTIZATION 0

SCREEN_PASS_TEXTURE_VIEWPORT(Color)
SCREEN_PASS_TEXTURE_VIEWPORT(Output)

#if MOBILE_MULTI_VIEW
Texture2DArray ColorTexture;
#else
Texture2D ColorTexture;
#endif
SamplerState ColorSampler;


FScreenTransform ColorToBloom;
float2 BloomUVViewportBilinearMin;
float2 BloomUVViewportBilinearMax;

#if MOBILE_MULTI_VIEW
	Texture2DArray BloomTexture;
#else
	Texture2D BloomTexture;
#endif
SamplerState BloomSampler;

#if SUPPORTS_SCENE_COLOR_APPLY_PARAMETERS
	StructuredBuffer<float4> SceneColorApplyParamaters;
#endif

#if LOCAL_EXPOSURE_MODE == LOCAL_EXPOSURE_MODE_BILATERAL
Texture3D LumBilateralGrid;
Texture2D BlurredLogLum;
SamplerState LumBilateralGridSampler;
SamplerState BlurredLogLumSampler;
#elif LOCAL_EXPOSURE_MODE == LOCAL_EXPOSURE_MODE_FUSION
FScreenTransform ColorToExposureFusion;
SCREEN_PASS_TEXTURE_VIEWPORT(ExposureFusion)
Texture2D ExposureFusionTexture;
SamplerState ExposureFusionSampler;
#endif

// xyz:SceneColorTint.rgb, w:unused
float4 ColorScale0;

// xyz:Bloom1Tint.rgb, w:unused
float4 ColorScale1;

// from the postprocess settings, x:VignetteIntensity, y:SharpenDiv6
float4 TonemapperParams;

// Grain quantization
float3 GrainRandomFull;

// Film grain
float FilmGrainIntensityShadows;
float FilmGrainIntensityMidtones;
float FilmGrainIntensityHighlights;
float FilmGrainShadowsMax;
float FilmGrainHighlightsMin;
float FilmGrainHighlightsMax;
Texture2D<half3> FilmGrainTexture;
SamplerState FilmGrainSampler;
float4 ScreenPosToFilmGrainTextureUV;
#if SUPPORTS_FILM_GRAIN
	StructuredBuffer<float4> FilmGrainTextureConstants;
#endif // SUPPORTS_FILM_GRAIN

float BackbufferQuantizationDithering;
float EditorNITLevel;

uint OutputDevice;
uint OutputGamut;
float OutputMaxLuminance;

float4 BloomDirtMaskTint;
Texture2D BloomDirtMaskTexture;
SamplerState BloomDirtMaskSampler;

float4 LensPrincipalPointOffsetScale;
float4 LensPrincipalPointOffsetScaleInverse;

uint GetOutputDevice()
{
#if OUTPUT_DEVICE_SRGB
	return TONEMAPPER_OUTPUT_sRGB;
#else
	return OutputDevice;
#endif
}

half GrainFromUV(float2 GrainUV) 
{
	half Grain = frac(sin(GrainUV.x + GrainUV.y * 543.31) *  493013.0);
	return Grain;
}

// converts from screen [-1,1] space to the lens [-1,1] viewport space
float2 ConvertScreenViewportSpaceToLensViewportSpace(float2 UV)
{
	return LensPrincipalPointOffsetScale.xy + UV * LensPrincipalPointOffsetScale.zw;
}

float2 ConvertLensViewportSpaceToScreenViewportSpace(float2 UV)
{
	// reference version
	//return (UV - LensPrincipalPointOffsetScale.xy)/LensPrincipalPointOffsetScale.zw;

	// optimized version
	return LensPrincipalPointOffsetScaleInverse.xy + UV * LensPrincipalPointOffsetScaleInverse.zw;
}

half3 LinearToPostTonemapSpace(half3 lin) 
{
#if IOS
	// Note, iOS native output is raw gamma 2.2 not sRGB!
	return pow(lin, 1.0 / 2.2);
#else
	return LinearToSrgbBranchless(lin);
#endif
}


// Nuke-style Color Correct
float ComputeFilmGrainIntensity(float3 LinearColorRGBGamut)
{
	const float3x3 sRGB_2_AP1 = mul( XYZ_2_AP1_MAT, mul( D65_2_D60_CAT, sRGB_2_XYZ_MAT ) );
	const float3x3 AP1_2_sRGB = mul( XYZ_2_sRGB_MAT, mul( D60_2_D65_CAT, AP1_2_XYZ_MAT ) );

	float3 ColorAP1 = mul(sRGB_2_AP1, LinearColorRGBGamut);
	
	//float Luma = dot(ColorAP1, AP1_RGB2Y);
	float Luma = dot(LinearColorRGBGamut,  mul(AP1_2_sRGB, AP1_RGB2Y));

	float CCWeightShadows = 1 - smoothstep(0, FilmGrainShadowsMax, Luma);
	float CCWeightHighlights = smoothstep(FilmGrainHighlightsMin, FilmGrainHighlightsMax, Luma);
	float CCWeightMidtones = 1 - CCWeightShadows - CCWeightHighlights;
	
	// Blend Shadow, Midtone and Highlight CCs
	float FilmGrainIntensity = (
		FilmGrainIntensityShadows * CCWeightShadows +
		FilmGrainIntensityMidtones * CCWeightMidtones +
		FilmGrainIntensityHighlights * CCWeightHighlights);
	
	return FilmGrainIntensity;
}


// LUT for color grading
#if USE_VOLUME_LUT == 1
	Texture3D		ColorGradingLUT;
#else
	Texture2D       ColorGradingLUT;
#endif 
SamplerState        ColorGradingLUTSampler;

float LUTSize;
float InvLUTSize; // 1 / LUTSize
float LUTScale; // (LUTSize - 1) / LUTSize
float LUTOffset; // 0.5 / LUTSize

half3 ColorLookupTable( half3 LinearColor )
{
	float3 LUTEncodedColor;
	// Encode as ST-2084 (Dolby PQ) values
	BRANCH
	if(GetOutputDevice() >= TONEMAPPER_OUTPUT_ACES1000nitST2084)
	{
		// ST2084 expects to receive linear values 0-10000 in nits.
		// So the linear value must be multiplied by a scale factor to convert to nits.
		// We don't send negative values to LinearToST2084 as it will result in NaN because of pow.
		LUTEncodedColor = LinearToST2084(clamp(LinearColor * LinearToNitsScale, 0.0, 10000.0));
	}
	else
	{
		LUTEncodedColor = LinToLog( LinearColor + LogToLin( 0 ) );
	}

	float3 UVW = LUTEncodedColor * LUTScale + LUTOffset;

#if USE_VOLUME_LUT == 1
	half3 OutDeviceColor = Texture3DSample( ColorGradingLUT, ColorGradingLUTSampler, UVW ).rgb;
#else
	half3 OutDeviceColor = UnwrappedTexture3DSample( ColorGradingLUT, ColorGradingLUTSampler, UVW, LUTSize, InvLUTSize ).rgb;
#endif
	
	return OutDeviceColor * 1.05;
}

// AGX Begin


// Mean error^2: 3.6705141e-06
float3 AgxDefaultContrastApprox(float3 x)
{
    const float3 x2 = x * x;
    const float3 x4 = x2 * x2;
 
    return +15.5 * x4 * x2
			- 40.14 * x4 * x
			+ 31.96 * x4
			- 6.868 * x2 * x
			+ 0.4298 * x2
			+ 0.1191 * x
			- 0.00232;
}

float3 Agx(float3 val)
{
    const float3x3 agx_mat = float3x3(
		0.842479062253094, 0.0423282422610123, 0.0423756549057051,
		0.0784335999999992, 0.878468636469772, 0.0784336,
		0.0792237451477643, 0.0791661274605434, 0.879142973793104);

	// DEFAULT_LOG2_MIN      = -10.0
	// DEFAULT_LOG2_MAX      =  +6.5
	// MIDDLE_GRAY           =  0.18
	// log2(pow(2, VALUE) * MIDDLE_GRAY)
	// Adjusted for Unreal's zero exposure compensation
    const float min_ev = -12.47393f; // Default: -12.47393f;
    const float max_ev = 0.526069f; // Default:  4.026069f;

	// Input transform (inset)
    val = mul(val, agx_mat);
  
	// Log2 space encoding
    val = clamp(log2(val), min_ev, max_ev);
    val = (val - min_ev) / (max_ev - min_ev);
  
	// Apply sigmoid function approximation
    val = AgxDefaultContrastApprox(val);

    return val;
}

float3 AgxEotf(float3 val)
{
    const float3x3 agx_mat_inv = float3x3(
		1.19687900512017, -0.0528968517574562, -0.0529716355144438,
		-0.0980208811401368, 1.15190312990417, -0.0980434501171241,
		-0.0990297440797205, -0.0989611768448433, 1.15107367264116);
	
	// Inverse input transform (outset)
    val = mul(val, agx_mat_inv);
  
	// sRGB IEC 61966-2-1 2.2 Exponent Reference EOTF Display
	// NOTE: We're linearizing the output here. Comment/adjust when
	// *not* using a sRGB render target
    val = pow(val, 2.2);

    return val; //LinearToSrgb(val);

}

float3 AgxLook(float3 val)
{
    const float3 lw = float3(0.2126, 0.7152, 0.0722);
    const float luma = dot(val, lw);
  
	// Default
    const float3 offset = float3(0.0, 0.0, 0.0);
    float3 slope = float3(1.0, 1.0, 1.0);
    float3 power = float3(1.0, 1.0, 1.0);
    float sat = 1.0;
 
#if AGX_LOOK == 1
	// Golden
	slope = float3(1.0, 0.9, 0.5);
	power = float3(0.8, 0.8, 0.8);
	sat = 0.8;
#elif AGX_LOOK == 2
	// Punchy
    slope = float3(1.0, 1.0, 1.0);
    power = float3(1.35, 1.35, 1.35);
    sat = 1.4;
#endif
  
	// ASC CDL
    val = pow(val * slope + offset, power);
    return luma + sat * (val - luma);
}

half3 ApplyAgX(half3 LinearColorRec709)
{
    LinearColorRec709 = Agx(LinearColorRec709);
    LinearColorRec709 = AgxLook(LinearColorRec709);
    LinearColorRec709 = AgxEotf(LinearColorRec709);
	
    return LinearColorRec709;
}
// AGX END

//GT START - GT7 Tonemapper (UE5 Compatible)
//[ Driving Toward Reality: Physically Based Tone Mapping and Perceptual Fidelity in Gran Turismo 7 SIGGRAPH 2025 ]

static const float3x3 Rec709ToRec2020 = float3x3(
				0.627402, 0.329292, 0.043306,
				0.069095, 0.919544, 0.011360,
				0.016394, 0.088028, 0.895578
			);

static const float3x3 Rec2020ToRec709 = float3x3(
				1.660496, -0.587656, -0.072840,
				-0.124547, 1.132895, -0.008348,
				-0.018151, -0.100597, 1.118748
			);

half3 ApplyGT(half3 Color) // IctCp based GT Tonemapper
{
	
    Color = mul(Color, Rec709ToRec2020);
	
	// Parameters from GT7
    half peakL = 10.0h; // Example: 1000 nits / 100 reference = 10.0 (adjustable)
    half alpha = 0.25h;
    half midPoint = 0.538h;
    half linearSection = 0.444h;
    half toeStrength = 1.28h;
    half ratio = 0.6h; // Blend ratio (untwisted weight)
    half f_s = 0.98h; // Smooth step start for chroma scaling
    half f_e = 1.16h; // Smooth step end
	// Precompute curve constants (from initialization)
    half k = (linearSection - 1.0h) / (alpha - 1.0h);
    half kA = peakL * linearSection + peakL * k;
    half kB = -peakL * k * exp(linearSection / k);
    half kC = -1.0h / (k * peakL);
	// Inline GT Tone Mapping V2 Curve for each channel
    half3 twisted;
	{
        half x = Color.r;
        if (x < 0.0h)
            twisted.r = 0.0h;
        else
        {
            half weightLinear = smoothstep(0.0h, midPoint, x);
            half weightToe = 1.0h - weightLinear;
            half shoulder = kA + kB * exp(x * kC);
            if (x < linearSection * peakL)
            {
                half toeMapped = midPoint * pow(x / midPoint, toeStrength);
                twisted.r = weightToe * toeMapped + weightLinear * x;
            }
            else
            {
                twisted.r = shoulder;
            }
        }
    }

	{
        half x = Color.g;
        if (x < 0.0h)
            twisted.g = 0.0h;
        else
        {
            half weightLinear = smoothstep(0.0h, midPoint, x);
            half weightToe = 1.0h - weightLinear;
            half shoulder = kA + kB * exp(x * kC);
            if (x < linearSection * peakL)
            {
                half toeMapped = midPoint * pow(x / midPoint, toeStrength);
                twisted.g = weightToe * toeMapped + weightLinear * x;
            }
            else
            {
                twisted.g = shoulder;
            }
        }
    }

	{
        half x = Color.b;
        if (x < 0.0h)
            twisted.b = 0.0h;
        else
        {
            half weightLinear = smoothstep(0.0h, midPoint, x);
            half weightToe = 1.0h - weightLinear;
            half shoulder = kA + kB * exp(x * kC);
            if (x < linearSection * peakL)
            {
                half toeMapped = midPoint * pow(x / midPoint, toeStrength);
                twisted.b = weightToe * toeMapped + weightLinear * x;
            }
            else
            {
                twisted.b = shoulder;
            }
        }
    }

	// Inline RGB to ICtCp (assuming linear Rec.2020 input; Color is linear)
    half3 originalUCS;
	{
        half3 rgb = Color;
        half l = (rgb.r * 1688.0h + rgb.g * 2146.0h + rgb.b * 262.0h) / 4096.0h;
        half m = (rgb.r * 683.0h + rgb.g * 2951.0h + rgb.b * 462.0h) / 4096.0h;
        half s = (rgb.r * 99.0h + rgb.g * 309.0h + rgb.b * 3688.0h) / 4096.0h;

		// Inline inverseEotfSt2084 for l, m, s
        half lPQ, mPQ, sPQ;
		{
            const half m1 = 0.1593017578125h;
            const half m2 = 78.84375h * 1.0h;
            const half c1 = 0.8359375h;
            const half c2 = 18.8515625h;
            const half c3 = 18.6875h;
            const half pqC = 10000.0h;
            half physical = l * 100.0h;
            half y = physical / pqC;
            half ym = pow(y, m1);
            half logTerm1 = log2(c1 + c2 * ym);
            half logTerm2 = log2(1.0h + c3 * ym);
            lPQ = exp2(m2 * (logTerm1 - logTerm2));
        }

		{
            const half m1 = 0.1593017578125h;
            const half m2 = 78.84375h * 1.0h;
            const half c1 = 0.8359375h;
            const half c2 = 18.8515625h;
            const half c3 = 18.6875h;
            const half pqC = 10000.0h;
            half physical = m * 100.0h;
            half y = physical / pqC;
            half ym = pow(y, m1);
            half logTerm1 = log2(c1 + c2 * ym);
            half logTerm2 = log2(1.0h + c3 * ym);
            mPQ = exp2(m2 * (logTerm1 - logTerm2));
        }

		{
            const half m1 = 0.1593017578125h;
            const half m2 = 78.84375h * 1.0h;
            const half c1 = 0.8359375h;
            const half c2 = 18.8515625h;
            const half c3 = 18.6875h;
            const half pqC = 10000.0h;
            half physical = s * 100.0h;
            half y = physical / pqC;
            half ym = pow(y, m1);
            half logTerm1 = log2(c1 + c2 * ym);
            half logTerm2 = log2(1.0h + c3 * ym);
            sPQ = exp2(m2 * (logTerm1 - logTerm2));

        }

        originalUCS.x = (2048.0h * lPQ + 2048.0h * mPQ) / 4096.0h; // I
        originalUCS.y = (6610.0h * lPQ - 13613.0h * mPQ + 7003.0h * sPQ) / 4096.0h; // Ct
        originalUCS.z = (17933.0h * lPQ - 17390.0h * mPQ - 543.0h * sPQ) / 4096.0h; // Cp
    }

    half3 twistedUCS;
	{
        half3 rgb = twisted;
        half l = (rgb.r * 1688.0h + rgb.g * 2146.0h + rgb.b * 262.0h) / 4096.0h;
        half m = (rgb.r * 683.0h + rgb.g * 2951.0h + rgb.b * 462.0h) / 4096.0h;
        half s = (rgb.r * 99.0h + rgb.g * 309.0h + rgb.b * 3688.0h) / 4096.0h;
		// Inline inverseEotfSt2084 for l, m, s (repeat)
        half lPQ, mPQ, sPQ;
		{
            const half m1 = 0.1593017578125h;
            const half m2 = 78.84375h * 1.0h;
            const half c1 = 0.8359375h;
            const half c2 = 18.8515625h;
            const half c3 = 18.6875h;
            const half pqC = 10000.0h;
            half physical = l * 100.0h;
            half y = physical / pqC;
            half ym = pow(y, m1);
            half logTerm1 = log2(c1 + c2 * ym);
            half logTerm2 = log2(1.0h + c3 * ym);
            lPQ = exp2(m2 * (logTerm1 - logTerm2));
        }

		{
            const half m1 = 0.1593017578125h;
            const half m2 = 78.84375h * 1.0h;
            const half c1 = 0.8359375h;
            const half c2 = 18.8515625h;
            const half c3 = 18.6875h;
            const half pqC = 10000.0h;
            half physical = m * 100.0h;
            half y = physical / pqC;
            half ym = pow(y, m1);
            half logTerm1 = log2(c1 + c2 * ym);
            half logTerm2 = log2(1.0h + c3 * ym);
            mPQ = exp2(m2 * (logTerm1 - logTerm2));
        }

		{
            const half m1 = 0.1593017578125h;
            const half m2 = 78.84375h * 1.0h;
            const half c1 = 0.8359375h;
            const half c2 = 18.8515625h;
            const half c3 = 18.6875h;
            const half pqC = 10000.0h;
            half physical = s * 100.0h;
            half y = physical / pqC;
            half ym = pow(y, m1);
            half logTerm1 = log2(c1 + c2 * ym);
            half logTerm2 = log2(1.0h + c3 * ym);
            sPQ = exp2(m2 * (logTerm1 - logTerm2));
        }

        twistedUCS.x = (2048.0h * lPQ + 2048.0h * mPQ) / 4096.0h; // I
        twistedUCS.y = (6610.0h * lPQ - 13613.0h * mPQ + 7003.0h * sPQ) / 4096.0h; // Ct
        twistedUCS.z = (17933.0h * lPQ - 17390.0h * mPQ - 543.0h * sPQ) / 4096.0h; // Cp
    }

	// Chroma scaling (whitening)
    half chromaScale = 1.0h - smoothstep(f_s, f_e, originalUCS.x / peakL); // Renamed to avoid conflict

	// Untwisted UCS: use twisted luma, scaled chroma
    half3 untwistedUCS = half3(twistedUCS.x, originalUCS.y * chromaScale, originalUCS.z * chromaScale);

	// Inline ICtCp to RGB for untwisted
    half3 untwisted;
	{
        half3 ictCp = untwistedUCS;
        half l = ictCp.x + 0.00860904h * ictCp.y + 0.11103h * ictCp.z;
        half m = ictCp.x - 0.00860904h * ictCp.y - 0.11103h * ictCp.z;
        half s = ictCp.x + 0.560031h * ictCp.y - 0.320627h * ictCp.z;
		// Inline eotfSt2084 for l, m, s
        half lLin, mLin, sLin;
		{
            half n = clamp(l, 0.0h, 1.0h);
            const half m1 = 0.1593017578125h;
            const half m2 = 78.84375h * 1.0h;
            const half c1 = 0.8359375h;
            const half c2 = 18.8515625h;
            const half c3 = 18.6875h;
            const half pqC = 10000.0h;
            half np = pow(n, 1.0h / m2);
            half ll = np - c1;
            ll = max(ll, 0.0h);
            ll = ll / (c2 - c3 * np);
            lLin = pow(ll, 1.0h / m1) * pqC / 100.0h;
        }

		{
            half n = clamp(m, 0.0h, 1.0h);
            const half m1 = 0.1593017578125h;
            const half m2 = 78.84375h * 1.0h;
            const half c1 = 0.8359375h;
            const half c2 = 18.8515625h;
            const half c3 = 18.6875h;
            const half pqC = 10000.0h;
            half np = pow(n, 1.0h / m2);
            half ll = np - c1;
            ll = max(ll, 0.0h);
            ll = ll / (c2 - c3 * np);
            mLin = pow(ll, 1.0h / m1) * pqC / 100.0h;
        }

		{
            half n = clamp(s, 0.0h, 1.0h);
            const half m1 = 0.1593017578125h;
            const half m2 = 78.84375h * 1.0h;
            const half c1 = 0.8359375h;
            const half c2 = 18.8515625h;
            const half c3 = 18.6875h;
            const half pqC = 10000.0h;
            half np = pow(n, 1.0h / m2);
            half ll = np - c1;
            ll = max(ll, 0.0h);
            ll = ll / (c2 - c3 * np);
            sLin = pow(ll, 1.0h / m1) * pqC / 100.0h;
        }
        untwisted.r = max(3.43661h * lLin - 2.50645h * mLin + 0.0698454h * sLin, 0.0h);
        untwisted.g = max(-0.79133h * lLin + 1.9836h * mLin - 0.192271h * sLin, 0.0h);
        untwisted.b = max(-0.0259499h * lLin - 0.0989137h * mLin + 1.12486h * sLin, 0.0h);
    }

	// Final blend
    half3 finalColor = lerp(twisted, untwisted, ratio);
	// For SDR: finalColor *= 1.0h / (250.0h / 100.0h); // 1/2.5
	//finalColor *= 2.0h; // Example adjustment if needed
    finalColor = mul(finalColor, Rec2020ToRec709);
    finalColor = LinearToSrgb(finalColor); //pow(finalColor, 1 / 2.2); //;
	
    return finalColor;
}



half3 ApplyGT2(half3 Color) // replaces the ICtCp pipeline with a Safdar2017 JzAzBz pipeline
{
    Color = mul(Color, Rec709ToRec2020);
	
    // Parameters from GT7
    half peakL = 10.0h;
    half alpha = 0.25h;
    half midPoint = 0.538h;
    half linearSection = 0.444h;
    half toeStrength = 1.28h;
    half ratio = 0.6h;
    half f_s = 0.98h;
    half f_e = 1.16h;
	
    // Precompute curve constants
    half k = (linearSection - 1.0h) / (alpha - 1.0h);
    half kA = peakL * linearSection + peakL * k;
    half kB = -peakL * k * exp(linearSection / k);
    half kC = -1.0h / (k * peakL);
	
    // Apply GT Tone Mapping per channel
    half3 twisted;
    {
        half x = Color.r;
        if (x < 0.0h)
            twisted.r = 0.0h;
        else
        {
            half weightLinear = smoothstep(0.0h, midPoint, x);
            half weightToe = 1.0h - weightLinear;
            half shoulder = kA + kB * exp(x * kC);
            if (x < linearSection * peakL)
            {
                half toeMapped = midPoint * pow(x / midPoint, toeStrength);
                twisted.r = weightToe * toeMapped + weightLinear * x;
            }
            else
            {
                twisted.r = shoulder;
            }
        }
    }

    {
        half x = Color.g;
        if (x < 0.0h)
            twisted.g = 0.0h;
        else
        {
            half weightLinear = smoothstep(0.0h, midPoint, x);
            half weightToe = 1.0h - weightLinear;
            half shoulder = kA + kB * exp(x * kC);
            if (x < linearSection * peakL)
            {
                half toeMapped = midPoint * pow(x / midPoint, toeStrength);
                twisted.g = weightToe * toeMapped + weightLinear * x;
            }
            else
            {
                twisted.g = shoulder;
            }
        }
    }

    {
        half x = Color.b;
        if (x < 0.0h)
            twisted.b = 0.0h;
        else
        {
            half weightLinear = smoothstep(0.0h, midPoint, x);
            half weightToe = 1.0h - weightLinear;
            half shoulder = kA + kB * exp(x * kC);
            if (x < linearSection * peakL)
            {
                half toeMapped = midPoint * pow(x / midPoint, toeStrength);
                twisted.b = weightToe * toeMapped + weightLinear * x;
            }
            else
            {
                twisted.b = shoulder;
            }
        }
    }

    // JzAzBz Constants (Safdar 2017)
    const half JZ_b = 1.15h;
    const half JZ_g = 0.66h;
    const half JZ_d = -0.56h;
    const half JZ_d0 = 1.6295499532821566e-11h;
    
    const half PQ_m1 = 0.1593017578125h;
    const half PQ_m2 = 134.03437500000000h;
    const half PQ_c1 = 0.8359375h;
    const half PQ_c2 = 18.8515625h;
    const half PQ_c3 = 18.6875h;
    const half PQ_C = 10000.0h;

    // Rec.2020 to XYZ (D65) matrix
    const half3 REC2020_TO_XYZ_R0 = half3(0.636953507h, 0.144619185h, 0.168855854h);
    const half3 REC2020_TO_XYZ_R1 = half3(0.262698339h, 0.678008776h, 0.0592928953h);
    const half3 REC2020_TO_XYZ_R2 = half3(4.99407097e-17h, 0.028073130h, 1.06082723h);

    // XYZ to LMS matrix
    const half3 XYZ_TO_LMS_R0 = half3(0.41478972h, 0.57999900h, 0.01464800h);
    const half3 XYZ_TO_LMS_R1 = half3(-0.20151000h, 1.12064900h, 0.05310080h);
    const half3 XYZ_TO_LMS_R2 = half3(-0.01660080h, 0.26480000h, 0.66847990h);

    // LMS' to IzAzBz matrix
    const half3 LMS_P_TO_IZAZBZ_R0 = half3(0.500000h, 0.500000h, 0.000000h);
    const half3 LMS_P_TO_IZAZBZ_R1 = half3(3.524000h, -4.066708h, 0.542708h);
    const half3 LMS_P_TO_IZAZBZ_R2 = half3(0.199076h, 1.096799h, -1.295875h);

    // IzAzBz to LMS' matrix (inverse)
    const half3 IZAZBZ_TO_LMS_P_R0 = half3(1.00000000h, 0.13860504h, 0.05804732h);
    const half3 IZAZBZ_TO_LMS_P_R1 = half3(1.00000000h, -0.13860504h, -0.05804732h);
    const half3 IZAZBZ_TO_LMS_P_R2 = half3(1.00000000h, -0.09601924h, -0.81189190h);

    // LMS to XYZ matrix (inverse)
    const half3 LMS_TO_XYZ_R0 = half3(1.92422644h, -1.00479231h, 0.03765140h);
    const half3 LMS_TO_XYZ_R1 = half3(0.35031676h, 0.72648119h, -0.06538442h);
    const half3 LMS_TO_XYZ_R2 = half3(-0.09098281h, -0.31272829h, 1.52276656h);

    // XYZ to Rec.2020 matrix (inverse)
    const half3 XYZ_TO_REC2020_R0 = half3(1.71666343h, -0.35567332h, -0.25336809h);
    const half3 XYZ_TO_REC2020_R1 = half3(-0.66667384h, 1.61645574h, 0.01576830h);
    const half3 XYZ_TO_REC2020_R2 = half3(0.01764248h, -0.04277698h, 0.94224328h);

    // === Forward: RGB to JzAzBz (original color) ===
    half3 originalJz;
    {
        half3 rgb = Color;
        
        // 1. RGB to XYZ
        half X = dot(rgb, REC2020_TO_XYZ_R0);
        half Y = dot(rgb, REC2020_TO_XYZ_R1);
        half Z = dot(rgb, REC2020_TO_XYZ_R2);
        
        // 2. Apply Xp, Yp adjustment
        half Xp = JZ_b * X - (JZ_b - 1.0h) * Z;
        half Yp = JZ_g * Y - (JZ_g - 1.0h) * X;
        
        // 3. XYZ' to LMS
        half3 XYZp = half3(Xp, Yp, Z);
        half l = dot(XYZp, XYZ_TO_LMS_R0);
        half m = dot(XYZp, XYZ_TO_LMS_R1);
        half s = dot(XYZp, XYZ_TO_LMS_R2);
        
        // 4. LMS to LMS' (inverse ST2084)
        half3 LMS = half3(l, m, s);
        half3 physical = LMS * 100.0h;
        half3 y = physical / PQ_C;
        half3 ym = pow(max(y, 1e-12h), PQ_m1);
        half3 logTerm1 = log2(PQ_c1 + PQ_c2 * ym);
        half3 logTerm2 = log2(1.0h + PQ_c3 * ym);
        half3 LMS_p = exp2(PQ_m2 * (logTerm1 - logTerm2));
        
        // 5. LMS' to IzAzBz
        half Iz = dot(LMS_p, LMS_P_TO_IZAZBZ_R0);
        half az = dot(LMS_p, LMS_P_TO_IZAZBZ_R1);
        half bz = dot(LMS_p, LMS_P_TO_IZAZBZ_R2);
        
        // 6. Iz to Jz
        half Jz = ((1.0h + JZ_d) * Iz) / (1.0h + JZ_d * Iz) - JZ_d0;
        
        originalJz = half3(Jz, az, bz);
    }

    // === Forward: RGB to JzAzBz (twisted color) ===
    half3 twistedJz;
    {
        half3 rgb = twisted;
        
        // 1. RGB to XYZ
        half X = dot(rgb, REC2020_TO_XYZ_R0);
        half Y = dot(rgb, REC2020_TO_XYZ_R1);
        half Z = dot(rgb, REC2020_TO_XYZ_R2);
        
        // 2. Apply Xp, Yp adjustment
        half Xp = JZ_b * X - (JZ_b - 1.0h) * Z;
        half Yp = JZ_g * Y - (JZ_g - 1.0h) * X;
        
        // 3. XYZ' to LMS
        half3 XYZp = half3(Xp, Yp, Z);
        half l = dot(XYZp, XYZ_TO_LMS_R0);
        half m = dot(XYZp, XYZ_TO_LMS_R1);
        half s = dot(XYZp, XYZ_TO_LMS_R2);
        
        // 4. LMS to LMS' (inverse ST2084)
        half3 LMS = half3(l, m, s);
        half3 physical = LMS * 100.0h;
        half3 y = physical / PQ_C;
        half3 ym = pow(max(y, 1e-12h), PQ_m1);
        half3 logTerm1 = log2(PQ_c1 + PQ_c2 * ym);
        half3 logTerm2 = log2(1.0h + PQ_c3 * ym);
        half3 LMS_p = exp2(PQ_m2 * (logTerm1 - logTerm2));
        
        // 5. LMS' to IzAzBz
        half Iz = dot(LMS_p, LMS_P_TO_IZAZBZ_R0);
        half az = dot(LMS_p, LMS_P_TO_IZAZBZ_R1);
        half bz = dot(LMS_p, LMS_P_TO_IZAZBZ_R2);
        
        // 6. Iz to Jz
        half Jz = ((1.0h + JZ_d) * Iz) / (1.0h + JZ_d * Iz) - JZ_d0;
        
        twistedJz = half3(Jz, az, bz);
    }

    // Chroma scaling based on original Jz lightness
    half chromaScale = 1.0h - smoothstep(f_s, f_e, originalJz.x / peakL);

    // Create untwisted: twisted lightness with scaled original chroma
    half3 untwistedJzAzBz = half3(twistedJz.x, originalJz.y * chromaScale, originalJz.z * chromaScale);

    // === Inverse: JzAzBz to RGB (untwisted) ===
    half3 untwistedRGB;
    {
        half3 JzAzBz_in = untwistedJzAzBz;
        
        // 1. Jz to Iz
        half Jz = JzAzBz_in.x;
        half az = JzAzBz_in.y;
        half bz = JzAzBz_in.z;
        half Iz = (Jz + JZ_d0) / (1.0h + JZ_d - JZ_d * (Jz + JZ_d0));
        
        // 2. IzAzBz to LMS'
        half3 IzAzBz = half3(Iz, az, bz);
        half lp = dot(IzAzBz, IZAZBZ_TO_LMS_P_R0);
        half mp = dot(IzAzBz, IZAZBZ_TO_LMS_P_R1);
        half sp = dot(IzAzBz, IZAZBZ_TO_LMS_P_R2);
        
        // 3. LMS' to LMS (forward ST2084)
        half3 LMS_p = half3(lp, mp, sp);
        half3 n = clamp(LMS_p, 0.0h, 1.0h);
        half3 npv = pow(n, 1.0h / PQ_m2);
        half3 ll = max(npv - PQ_c1, 0.0h);
        ll = ll / (PQ_c2 - PQ_c3 * npv);
        half3 LMS = pow(ll, 1.0h / PQ_m1) * PQ_C / 100.0h;
        
        // 4. LMS to XYZ'
        half Xp = dot(LMS, LMS_TO_XYZ_R0);
        half Yp = dot(LMS, LMS_TO_XYZ_R1);
        half Zp = dot(LMS, LMS_TO_XYZ_R2);
        
        // 5. XYZ' to XYZ (inverse adjustment)
        half X = (Xp + (JZ_b - 1.0h) * Zp) / JZ_b;
        half Y = (Yp + (JZ_g - 1.0h) * X) / JZ_g;
        half Z = Zp;
        
        // 6. XYZ to RGB
        half3 XYZ = half3(X, Y, Z);
        half r = dot(XYZ, XYZ_TO_REC2020_R0);
        half g = dot(XYZ, XYZ_TO_REC2020_R1);
        half b = dot(XYZ, XYZ_TO_REC2020_R2);
        
        untwistedRGB = half3(r, g, b);
    }

    // Final blend
    half3 finalColor = lerp(twisted, untwistedRGB, ratio);
    
    finalColor = mul(finalColor, Rec2020ToRec709);
    finalColor = LinearToSrgb(finalColor);
	
    return finalColor;
}

half3 ApplyGT3(half3 Color)
{
    Color = mul(Color, Rec709ToRec2020);
	
    // Parameters from GT7
    half peakL = 10.0h;
    half alpha = 0.25h;
    half midPoint = 0.538h;
    half linearSection = 0.444h;
    half toeStrength = 1.28h;
    half ratio = 0.6h;
    half f_s = 0.98h;
    half f_e = 1.16h;
	
    // Precompute curve constants
    half k = (linearSection - 1.0h) / (alpha - 1.0h);
    half kA = peakL * linearSection + peakL * k;
    half kB = -peakL * k * exp(linearSection / k);
    half kC = -1.0h / (k * peakL);
	
    // Apply GT Tone Mapping per channel
    half3 twisted;
    {
        half x = Color.r;
        if (x < 0.0h)
            twisted.r = 0.0h;
        else
        {
            half weightLinear = smoothstep(0.0h, midPoint, x);
            half weightToe = 1.0h - weightLinear;
            half shoulder = kA + kB * exp(x * kC);
            if (x < linearSection * peakL)
            {
                half toeMapped = midPoint * pow(x / midPoint, toeStrength);
                twisted.r = weightToe * toeMapped + weightLinear * x;
            }
            else
            {
                twisted.r = shoulder;
            }
        }
    }

    {
        half x = Color.g;
        if (x < 0.0h)
            twisted.g = 0.0h;
        else
        {
            half weightLinear = smoothstep(0.0h, midPoint, x);
            half weightToe = 1.0h - weightLinear;
            half shoulder = kA + kB * exp(x * kC);
            if (x < linearSection * peakL)
            {
                half toeMapped = midPoint * pow(x / midPoint, toeStrength);
                twisted.g = weightToe * toeMapped + weightLinear * x;
            }
            else
            {
                twisted.g = shoulder;
            }
        }
    }

    {
        half x = Color.b;
        if (x < 0.0h)
            twisted.b = 0.0h;
        else
        {
            half weightLinear = smoothstep(0.0h, midPoint, x);
            half weightToe = 1.0h - weightLinear;
            half shoulder = kA + kB * exp(x * kC);
            if (x < linearSection * peakL)
            {
                half toeMapped = midPoint * pow(x / midPoint, toeStrength);
                twisted.b = weightToe * toeMapped + weightLinear * x;
            }
            else
            {
                twisted.b = shoulder;
            }
        }
    }

    // --- Safdar2021 / ZCAM constants & matrices ---
    const half JZ_b = 1.15h;
    const half JZ_g = 0.66h;
    const half JZ_d = -0.56h;
    // Safdar2021 / ZCAM d_0
    const half JZ_d0 = 3.7035226210190005e-11h;
    
    const half PQ_m1 = 0.1593017578125h;
    // keep PQ_m2 as used (re-optimized m2)
    const half PQ_m2 = 134.03437500000000h;
    const half PQ_c1 = 0.8359375h;
    const half PQ_c2 = 18.8515625h;
    const half PQ_c3 = 18.6875h;
    const half PQ_C = 10000.0h;

    // Rec.2020 to XYZ (D65) matrix
    const half3 REC2020_TO_XYZ_R0 = half3(0.636953507h, 0.144619185h, 0.168855854h);
    const half3 REC2020_TO_XYZ_R1 = half3(0.262698339h, 0.678008776h, 0.0592928953h);
    const half3 REC2020_TO_XYZ_R2 = half3(4.99407097e-17h, 0.028073130h, 1.06082723h);

    // XYZ to LMS matrix
    const half3 XYZ_TO_LMS_R0 = half3(0.41478972h, 0.57999900h, 0.01464800h);
    const half3 XYZ_TO_LMS_R1 = half3(-0.20151000h, 1.12064900h, 0.05310080h);
    const half3 XYZ_TO_LMS_R2 = half3(-0.01660080h, 0.26480000h, 0.66847990h);

    // --- Safdar2021 LMS' -> IzAzBz matrix (first row [0,1,0]) ---
    const half3 LMS_P_TO_IZAZBZ_R0 = half3(0.000000h, 1.000000h, 0.000000h);
    const half3 LMS_P_TO_IZAZBZ_R1 = half3(3.524000h, -4.066708h, 0.542708h);
    const half3 LMS_P_TO_IZAZBZ_R2 = half3(0.199076h, 1.096799h, -1.295875h);

    // === IzAzBz -> LMS' matrix for Safdar2021 (numeric inverse of above) ===
    // precomputed inverse rows (precision trimmed)
    const half3 IZAZBZ_TO_LMS_P_R0 = half3(1.00000000h, 0.27721009h, 0.11609463h);
    const half3 IZAZBZ_TO_LMS_P_R1 = half3(1.00000000h, 0.00000000h, 0.00000000h);
    const half3 IZAZBZ_TO_LMS_P_R2 = half3(1.00000000h, 0.04258580h, -0.75384458h);

    // LMS to XYZ matrix (inverse)
    const half3 LMS_TO_XYZ_R0 = half3(1.92422644h, -1.00479231h, 0.03765140h);
    const half3 LMS_TO_XYZ_R1 = half3(0.35031676h, 0.72648119h, -0.06538442h);
    const half3 LMS_TO_XYZ_R2 = half3(-0.09098281h, -0.31272829h, 1.52276656h);

    // XYZ to Rec.2020 matrix (inverse)
    const half3 XYZ_TO_REC2020_R0 = half3(1.71666343h, -0.35567332h, -0.25336809h);
    const half3 XYZ_TO_REC2020_R1 = half3(-0.66667384h, 1.61645574h, 0.01576830h);
    const half3 XYZ_TO_REC2020_R2 = half3(0.01764248h, -0.04277698h, 0.94224328h);

    // === Forward: RGB to JzAzBz (original color) ===
    half3 originalJz;
    {
        half3 rgb = Color;
        
        // 1. RGB to XYZ
        half X = dot(rgb, REC2020_TO_XYZ_R0);
        half Y = dot(rgb, REC2020_TO_XYZ_R1);
        half Z = dot(rgb, REC2020_TO_XYZ_R2);
        
        // 2. Apply Xp, Yp adjustment
        half Xp = JZ_b * X - (JZ_b - 1.0h) * Z;
        half Yp = JZ_g * Y - (JZ_g - 1.0h) * X;
        
        // 3. XYZ' to LMS
        half3 XYZp = half3(Xp, Yp, Z);
        half l = dot(XYZp, XYZ_TO_LMS_R0);
        half m = dot(XYZp, XYZ_TO_LMS_R1);
        half s = dot(XYZp, XYZ_TO_LMS_R2);
        
        // 4. LMS to LMS' (inverse ST2084)
        half3 LMS = half3(l, m, s);
        half3 physical = LMS * 100.0h;
        half3 y = physical / PQ_C;
        half3 ym = pow(max(y, 1e-12h), PQ_m1);
        half3 logTerm1 = log2(PQ_c1 + PQ_c2 * ym);
        half3 logTerm2 = log2(1.0h + PQ_c3 * ym);
        half3 LMS_p = exp2(PQ_m2 * (logTerm1 - logTerm2));
        
        // 5. LMS' to IzAzBz (Safdar2021)
        half Iz = dot(LMS_p, LMS_P_TO_IZAZBZ_R0);
        half az = dot(LMS_p, LMS_P_TO_IZAZBZ_R1);
        half bz = dot(LMS_p, LMS_P_TO_IZAZBZ_R2);
        
        // 6. Iz to Jz (use Safdar d_0)
        half Jz = ((1.0h + JZ_d) * Iz) / (1.0h + JZ_d * Iz) - JZ_d0;
        
        originalJz = half3(Jz, az, bz);
    }

    // === Forward: RGB to JzAzBz (twisted color) ===
    half3 twistedJz;
    {
        half3 rgb = twisted;
        
        // 1. RGB to XYZ
        half X = dot(rgb, REC2020_TO_XYZ_R0);
        half Y = dot(rgb, REC2020_TO_XYZ_R1);
        half Z = dot(rgb, REC2020_TO_XYZ_R2);
        
        // 2. Apply Xp, Yp adjustment
        half Xp = JZ_b * X - (JZ_b - 1.0h) * Z;
        half Yp = JZ_g * Y - (JZ_g - 1.0h) * X;
        
        // 3. XYZ' to LMS
        half3 XYZp = half3(Xp, Yp, Z);
        half l = dot(XYZp, XYZ_TO_LMS_R0);
        half m = dot(XYZp, XYZ_TO_LMS_R1);
        half s = dot(XYZp, XYZ_TO_LMS_R2);
        
        // 4. LMS to LMS' (inverse ST2084)
        half3 LMS = half3(l, m, s);
        half3 physical = LMS * 100.0h;
        half3 y = physical / PQ_C;
        half3 ym = pow(max(y, 1e-12h), PQ_m1);
        half3 logTerm1 = log2(PQ_c1 + PQ_c2 * ym);
        half3 logTerm2 = log2(1.0h + PQ_c3 * ym);
        half3 LMS_p = exp2(PQ_m2 * (logTerm1 - logTerm2));
        
        // 5. LMS' to IzAzBz (Safdar2021)
        half Iz = dot(LMS_p, LMS_P_TO_IZAZBZ_R0);
        half az = dot(LMS_p, LMS_P_TO_IZAZBZ_R1);
        half bz = dot(LMS_p, LMS_P_TO_IZAZBZ_R2);
        
        // 6. Iz to Jz (use Safdar d_0)
        half Jz = ((1.0h + JZ_d) * Iz) / (1.0h + JZ_d * Iz) - JZ_d0;
        
        twistedJz = half3(Jz, az, bz);
    }

    // Chroma scaling based on original Jz lightness
    half chromaScale = 1.0h - smoothstep(f_s, f_e, originalJz.x / peakL);

    // Create untwisted: twisted lightness with scaled original chroma
    half3 untwistedJzAzBz = half3(twistedJz.x, originalJz.y * chromaScale, originalJz.z * chromaScale);

    // === Inverse: JzAzBz to RGB (untwisted) ===
    half3 untwistedRGB;
    {
        half3 JzAzBz_in = untwistedJzAzBz;
        
        // 1. Jz to Iz (Safdar2021 d_0)
        half Jz = JzAzBz_in.x;
        half az = JzAzBz_in.y;
        half bz = JzAzBz_in.z;
        half Iz = (Jz + JZ_d0) / (1.0h + JZ_d - JZ_d * (Jz + JZ_d0));
        
        // 2. IzAzBz to LMS' (Safdar2021 inverse matrix)
        half3 IzAzBz = half3(Iz, az, bz);
        half lp = dot(IzAzBz, IZAZBZ_TO_LMS_P_R0);
        half mp = dot(IzAzBz, IZAZBZ_TO_LMS_P_R1);
        half sp = dot(IzAzBz, IZAZBZ_TO_LMS_P_R2);
        
        // 3. LMS' to LMS (forward ST2084)
        half3 LMS_p = half3(lp, mp, sp);
        half3 n = clamp(LMS_p, 0.0h, 1.0h);
        half3 npv = pow(n, 1.0h / PQ_m2);
        half3 ll = max(npv - PQ_c1, 0.0h);
        ll = ll / (PQ_c2 - PQ_c3 * npv);
        half3 LMS = pow(ll, 1.0h / PQ_m1) * PQ_C / 100.0h;
        
        // 4. LMS to XYZ'
        half Xp = dot(LMS, LMS_TO_XYZ_R0);
        half Yp = dot(LMS, LMS_TO_XYZ_R1);
        half Zp = dot(LMS, LMS_TO_XYZ_R2);
        
        // 5. XYZ' to XYZ (inverse adjustment)
        half X = (Xp + (JZ_b - 1.0h) * Zp) / JZ_b;
        half Y = (Yp + (JZ_g - 1.0h) * X) / JZ_g;
        half Z = Zp;
        
        // 6. XYZ to RGB
        half3 XYZ = half3(X, Y, Z);
        half r = dot(XYZ, XYZ_TO_REC2020_R0);
        half g = dot(XYZ, XYZ_TO_REC2020_R1);
        half b = dot(XYZ, XYZ_TO_REC2020_R2);
        
        untwistedRGB = half3(r, g, b);
    }

    // Final blend
    half3 finalColor = lerp(twisted, untwistedRGB, ratio);
    
    finalColor = mul(finalColor, Rec2020ToRec709);
    finalColor = LinearToSrgb(finalColor);
	
    return finalColor;
}

//GT END


// can be optimized
float2 ScreenPosToUV(float2 ScreenPos, float2 ExtentInverse)
{
	float2 UV = (ScreenPos * Color_ScreenPosToViewportScale + Color_ScreenPosToViewportBias) * ExtentInverse;

	return UV;
}

float2 UVToScreenPos(float2 UV, float2 Extent)
{
	return (UV * Extent - Color_ScreenPosToViewportBias) / Color_ScreenPosToViewportScale;
}

float4 ChromaticAberrationParams;

void TonemapCommonVS(
	in	float4 Position,
	in	float2 TexCoord,
	out	float2 OutVignette,
	out	float4 OutGrainUV,
	out	float2 OutScreenPos,
	out	float2 OutFullViewUV
	)
{
	// Forward renderer uses view size texture
	// TODO: Looks to be Ronin specific.. check this:
	OutFullViewUV.xy = Position.xy * float2(0.5,-0.5) + 0.5;

	const float AspectRatio = Output_ViewportSize.y * Output_ViewportSizeInverse.x;

	float2 ColorViewportPos = UVToScreenPos(TexCoord, Color_Extent);

	// Scale vignette to always be a circle with consistent corner intensity.
	float2 LensViewportPos = ConvertScreenViewportSpaceToLensViewportSpace(ColorViewportPos);
	OutVignette = VignetteSpace(LensViewportPos, AspectRatio);

	// Grain
	OutGrainUV.xy = TexCoord + Color_ExtentInverse * float2(-0.5,0.5);
	#if DEBUG_GRAIN_QUANTIZATION
		OutGrainUV.zw = TexCoord;
	#else
		OutGrainUV.zw = TexCoord + GrainRandomFull.xy;
	#endif

	// Fringe
	OutScreenPos = UVToScreenPos(TexCoord, Color_Extent);
}

// vertex shader entry point
void MainVS(
	in 					float4 InPosition 				: ATTRIBUTE0,
	in 					float2 InTexCoord 				: ATTRIBUTE1,
	out noperspective 	float2 OutTexCoord 				: TEXCOORD0,
	out noperspective 	float2 OutVignette				: TEXCOORD1,
	out noperspective 	float4 OutGrainUV 				: TEXCOORD2,
	out noperspective 	float2 OutScreenPos 			: TEXCOORD3,
	out noperspective 	float2 OutFullViewUV 			: TEXCOORD4,
	in FStereoVSInput StereoInput,
	out FStereoVSOutput StereoOutput,
	out 				float4 OutPosition 				: SV_POSITION
	)
{
	StereoSetupVS(StereoInput, StereoOutput);
	DrawRectangle(InPosition, InTexCoord, OutPosition, OutTexCoord);
    TonemapCommonVS(OutPosition, OutTexCoord, OutVignette, OutGrainUV, OutScreenPos, OutFullViewUV);
}

float max4(float4 x)
{
	return max(max(x.r, x.g), max(x.b, x.a));
}

float4 SampleSceneColor(float2 SceneUV, float ArrayIndex)
{
	SceneUV = clamp(SceneUV, Color_UVViewportBilinearMin, Color_UVViewportBilinearMax);
#if MOBILE_MULTI_VIEW
	return Texture2DArraySample(ColorTexture, ColorSampler, float3(SceneUV.xy,ArrayIndex));
#else
	return Texture2DSample(ColorTexture, ColorSampler, SceneUV);
#endif
}

half3 LookupSceneColor(float2 SceneUV, float ArrayIndex, float2 PixelOffset)
{
	float2 SampleUV = SceneUV + PixelOffset * Color_ExtentInverse;
	return SampleSceneColor(SampleUV, ArrayIndex).xyz;
}



float4 TonemapCommonPS(
	float3 UV,
	float2 Vignette,
	float4 GrainUV,
	float2 ScreenPos, // [-1, 1]x[-1, 1]
	float2 FullViewUV,
	float4 SvPosition,
	out float OutLuminance
	)
{
	const float OneOverPreExposure = View.OneOverPreExposure;
	const float2 EyeAdaptationData = EyeAdaptationBuffer[0].xw;
	const float GlobalExposure = EyeAdaptationData.x;

	float2 SceneUV = UV.xy;
	float ArrayIndex = UV.z;

	// Sample the scene color.
	half4 SceneColor;
	{
		#if USE_COLOR_FRINGE
			float2 SceneUVJitter = float2(0.0, 0.0);
		
				float2 CAScale = ChromaticAberrationParams.rg;
				float StartOffset = ChromaticAberrationParams.z;

				float2 LensUV = ConvertScreenViewportSpaceToLensViewportSpace(ScreenPos);

				float4 CAUV;
				CAUV = LensUV.xyxy - sign(LensUV).xyxy * saturate(abs(LensUV) - StartOffset).xyxy * CAScale.rrgg;

				CAUV.xy = ConvertLensViewportSpaceToScreenViewportSpace(CAUV.xy);
				CAUV.zw = ConvertLensViewportSpaceToScreenViewportSpace(CAUV.zw);

				CAUV.xy = ScreenPosToUV(CAUV.xy, Color_ExtentInverse);
				CAUV.zw = ScreenPosToUV(CAUV.zw, Color_ExtentInverse);

			half4 SceneColorR = SampleSceneColor(CAUV.xy + SceneUVJitter.xy, ArrayIndex);
			half SceneColorG = SampleSceneColor(CAUV.zw + SceneUVJitter.xy, ArrayIndex).g;
			half SceneColorB = SampleSceneColor(SceneUV, ArrayIndex).b;
			SceneColor = SceneColorR;
			SceneColor.g = SceneColorG;
			SceneColor.b = SceneColorB;
		#else
			SceneColor = SampleSceneColor(SceneUV, ArrayIndex);
		#endif

		#if METAL_MSAA_HDR_DECODE && !USE_GAMMA_ONLY
			// look for PreTonemapMSAA 
			SceneColor.rgb *= rcp(SceneColor.r * (-0.299) + SceneColor.g * (-0.587) + SceneColor.b * (-0.114) + 1.0);
			// Try to kill negatives and NaNs here
			SceneColor.rgb = max(SceneColor.rgb, 0);
		#endif
	}

	// Sample bloom & mobile's vignette.
	#if FEATURE_LEVEL == FEATURE_LEVEL_ES3_1
		float MobileVignette;
	#else
		const float MobileVignette = 1.0;
	#endif
	
	half3 Bloom;
	{
		float2 BloomUV;
		#if ES3_1_PROFILE
		{
			BloomUV = FullViewUV.xy;
		}
		#else
		{
			BloomUV = ApplyScreenTransform(UV.xy, ColorToBloom);
			BloomUV = clamp(BloomUV, BloomUVViewportBilinearMin, BloomUVViewportBilinearMax);
		}
		#endif

		float4 RawBloom;
		#if MOBILE_MULTI_VIEW
			RawBloom = Texture2DArraySample(BloomTexture, BloomSampler, float3(BloomUV,ArrayIndex));
		#else
			RawBloom = Texture2DSample(BloomTexture, BloomSampler, BloomUV);
		#endif

		#if FEATURE_LEVEL == FEATURE_LEVEL_ES3_1
		{
			// Support sunshaft and vignette for mobile, and we have applied the BloomIntensity and the BloomDirtMask at the sun merge pass.
			Bloom = RawBloom.rgb;
			MobileVignette = RawBloom.a;
		}
		#else
		{
			float2 DirtLensUV = ConvertScreenViewportSpaceToLensViewportSpace(ScreenPos) * float2(1.0f, -1.0f);

			float3 RawBloomDirt = Texture2DSample(BloomDirtMaskTexture, BloomDirtMaskSampler, DirtLensUV * .5f + .5f).rgb;

			Bloom = RawBloom.rgb * (1.0 + RawBloomDirt * BloomDirtMaskTint.rgb);
		}
		#endif
	}
	
	// Compute scene color tint.
	#if USE_GAMMA_ONLY
		const float3 SceneColorTint = 1.0;
	#elif SUPPORTS_SCENE_COLOR_APPLY_PARAMETERS
		// Note that SceneColorApplyParamaters[0] is only for FFT bloom energy conservativeness = doesn't need to be in PreExposure
		const float3 SceneColorTint = ColorScale0.rgb * SceneColorApplyParamaters[0].xyz;
	#else
		const float3 SceneColorTint = ColorScale0.rgb;
	#endif

	// Compute the local exposure based of the scene color.
	#if LOCAL_EXPOSURE_MODE == LOCAL_EXPOSURE_MODE_BILATERAL
	float LocalExposure = 1.0;
	{
		float LuminanceVal = CalculateEyeAdaptationLuminance(SceneColor.rgb * OneOverPreExposure);
		float LogLuminance = log2(LuminanceVal);

		// Middle grey lum value adjusted by exposure compensation
		float MiddleGreyLumValue = log2(0.18 * EyeAdaptationData.y * LocalExposure_MiddleGreyExposureCompensation);

		float BaseLogLum = CalculateBaseLogLuminance(LogLuminance, LocalExposure_BlurredLuminanceBlend, GlobalExposure, FullViewUV, LumBilateralGrid, BlurredLogLum, LumBilateralGridSampler, BlurredLogLumSampler);
		LocalExposure = CalculateLocalExposure(LogLuminance + log2(GlobalExposure), BaseLogLum, MiddleGreyLumValue, LocalExposure_HighlightContrastScale, LocalExposure_ShadowContrastScale, LocalExposure_DetailStrength);
	}
	#elif LOCAL_EXPOSURE_MODE == LOCAL_EXPOSURE_MODE_FUSION
	float LocalExposure = 1.0;
	{
		float2 ExposureFusionUV = ApplyScreenTransform(UV.xy, ColorToExposureFusion);
		ExposureFusionUV = clamp(ExposureFusionUV, ExposureFusion_UVViewportBilinearMin, ExposureFusion_UVViewportBilinearMax);

		const float FusionVal = Texture2DSample(ExposureFusionTexture, ExposureFusionSampler, ExposureFusionUV).x;

		const float LuminanceVal = CalculateEyeAdaptationLuminance(SceneColor.rgb * OneOverPreExposure * GlobalExposure);
		
		LocalExposure = CalculateFusionLocalExposure(LuminanceVal, FusionVal);
	}
	#else // LOCAL_EXPOSURE_MODE_NONE
	const float LocalExposure = 1.0;
	#endif

	// Apply sharpening onto SceneColor.
	#if USE_SHARPEN
	{
		// 0..x, 0:no effect .. 1:strong, from r.Tonemapper.Sharpen
		// Div6 is to save one instruction
		float SharpenMultiplierDiv6 = TonemapperParams.y;

		half A0 = Luminance(SceneColor.rgb);

	#if HAS_PIXEL_QUAD_MESSAGE_PASSING_SUPPORT
		// Use Wave Intrinsics to reduce texture taps
		FPQMPContext PQMP = PQMPInit(floor(SceneUV* Color_Extent));
				
		half4 LuminanceNeighbors;
		
		half3 C1 = LookupSceneColor(SceneUV, ArrayIndex, float2(PQMP.QuadVector.x, 0)).rgb;
		half3 C3 = LookupSceneColor(SceneUV, ArrayIndex, float2(0, PQMP.QuadVector.y)).rgb;
		LuminanceNeighbors.x = Luminance(C1);
		LuminanceNeighbors.y = Luminance(C3);
		
		half3 C2 = PQMPReadX(PQMP, SceneColor.rgb);
		half3 C4 = PQMPReadY(PQMP, SceneColor.rgb);
		LuminanceNeighbors.z =  PQMPReadX(PQMP,A0);
		LuminanceNeighbors.w =  PQMPReadY(PQMP,A0);
	#else
		half3 C1 = LookupSceneColor(SceneUV, ArrayIndex, float2(-1,  0));
		half3 C2 = LookupSceneColor(SceneUV, ArrayIndex, float2( 1,  0));
		half3 C3 = LookupSceneColor(SceneUV, ArrayIndex, float2( 0, -1));
		half3 C4 = LookupSceneColor(SceneUV, ArrayIndex, float2( 0,  1));
		half4 LuminanceNeighbors = half4(Luminance(C1), Luminance(C2), Luminance(C3), Luminance(C4));
	#endif

		// compute mask to not sharpen near very bright HDR content
		// Note: using max instead of summming up saves 1 instruction
		// Note: We could multiply this to tweak the edge weight but it might instroduce a cost
		half HDREdge = (OneOverPreExposure * LocalExposure * GlobalExposure) * max4(abs(A0 - LuminanceNeighbors));
	
		// 0..1
		half EdgeMask = saturate(1.0f - HDREdge);

		// -1:sharpen, 0:no effect, 1:blur
		float LerpFactor = -EdgeMask * SharpenMultiplierDiv6;

		// optimized, Div6 went into the C++ code
		half3 DeltaColor = (C1 + C2 + C3 + C4) - SceneColor.rgb * 4;

		SceneColor.rgb += DeltaColor * LerpFactor;
	}
	#endif // USE_SHARPEN

#if FEATURE_LEVEL == FEATURE_LEVEL_ES3_1
	// Mobile device composers expect 1.0 in alpha
	float4 OutColor = float4(0.0, 0.0, 0.0, 1.0);
#else
	float4 OutColor = 0;
#endif

#if USE_GAMMA_ONLY
	{
		#if LOCAL_EXPOSURE_MODE != LOCAL_EXPOSURE_MODE_NONE
			#error Local exposure is not supported with gamma only
		#endif
		#if USE_SHARPEN
			#error Sharpen is not supported with gamma only
		#endif

		OutColor.rgb = pow(SceneColor.rgb * (OneOverPreExposure * GlobalExposure), InverseGamma.x);

		OutLuminance = Luminance(OutColor.rgb);
	}
#else // !USE_GAMMA_ONLY
	{
		// Compute vignette.
		float VignetteMask = MobileVignette;
		
		BRANCH
		if (TonemapperParams.x > 0.0f)
		{
			VignetteMask *= ComputeVignetteMask(Vignette, TonemapperParams.x);
		}
		
		// Compute the final linear color space with explicitly all the terms that should affect the pre exposure.
		half3 FinalLinearColor = SceneColor.rgb * SceneColorTint * (OneOverPreExposure * GlobalExposure * VignetteMask * LocalExposure);
		
		// Apply bloom.
		FinalLinearColor += Bloom * (OneOverPreExposure * GlobalExposure * VignetteMask);
		
		// Film grain is energy conservative so doesn't need to be taken into PreExposure
#if USE_FILM_GRAIN
		{
			float3 FilmGrainDecodeMultiply = FilmGrainTextureConstants[0].rgb;

			half FilmGrainIntensity = ComputeFilmGrainIntensity(FinalLinearColor);

			float2 FilmGrainUV = ApplyScreenTransform(ScreenPos, ScreenPosToFilmGrainTextureUV);

			half3 RawGrain = FilmGrainTexture.SampleLevel(FilmGrainSampler, FilmGrainUV, 0);
			half3 FinalGrain = RawGrain * half3(FilmGrainDecodeMultiply);

			FinalLinearColor.rgb *= lerp(1.0, FinalGrain, FilmGrainIntensity);
		}
#endif
		

#if TONEMAPPER_MODE == 0		
        half3 OutDeviceColor = ColorLookupTable(FinalLinearColor);
#elif TONEMAPPER_MODE == 1
        half3 OutDeviceColor = ApplyAgX(FinalLinearColor); //*.85
#elif TONEMAPPER_MODE == 2
        half3 OutDeviceColor = ApplyGT(FinalLinearColor); // .4 *
#elif TONEMAPPER_MODE == 3
        half3 OutDeviceColor = ApplyGT2(FinalLinearColor); // .4 *
#elif TONEMAPPER_MODE == 4
        half3 OutDeviceColor = ApplyGT3(FinalLinearColor);
#else
		half3 OutDeviceColor =LinearTosRGB(FinalLinearColor);
#endif

		half LuminanceForPostProcessAA = dot(OutDeviceColor, half3(0.299f, 0.587f, 0.114f));
		OutLuminance = LuminanceForPostProcessAA;

		// RETURN_COLOR not needed unless writing to SceneColor
		OutColor.rgb = OutDeviceColor;
        OutColor.a = OutLuminance;

		#if USE_LINEAR_FLOAT_RT
			OutColor.rgb = sRGBToLinear( OutColor.rgb );
		#endif

		BRANCH
		if(GetOutputDevice() == TONEMAPPER_OUTPUT_LinearEXR)
		{
			OutColor.xyz = ST2084ToLinear(OutColor.xyz);
		}
		else
		{
            OutColor.xyz = OutDeviceColor;
        }
	}
#endif // !USE_GAMMA_ONLY
	
	#if !USE_GAMMA_ONLY
	{
		// Compute uniform grain on [0;1]
		half UniformGrainOP = GrainFromUV(GrainUV.zw); //TODO: verify the quality of GrainFromUV()

		// Compute uniform grain on [-1;1]
		half UniformGrainNP = UniformGrainOP * 2.0 - 1.0;
		half UniformGrainNPSign = clamp(UniformGrainNP * POSITIVE_INFINITY, half(-1.0), half(1.0));
		
		// Compute triangular grain on [-1;1]
		// half TriangularGrainOP = UniformGrainNPSign * (1.0 - sqrt(1.0 - abs(UniformGrainNP)));
		half TriangularGrainOP = UniformGrainNPSign - UniformGrainNPSign * sqrt(saturate(half(1.0) - abs(UniformGrainNP)));
		
		// Selects the grain to use.
		half FinalGrain = 0.0;
		#if DEBUG_GRAIN_QUANTIZATION
			if (ScreenPos.y > 1.0 / 3.0)
				FinalGrain = TriangularGrainOP;
			else if (ScreenPos.y < -1.0 / 3.0)
				FinalGrain = UniformGrainOP - 0.5;
		#elif 0
			FinalGrain = UniformGrainOP - 0.5;
		#else
			FinalGrain = TriangularGrainOP;
		#endif

		// Debug grain quantization.
		#if DEBUG_GRAIN_QUANTIZATION
		{
			half Quantization = 10.0;
			
			OutColor.rgb = round(OutColor.rgb * Quantization + FinalGrain) * rcp(Quantization);
			OutColor.rgb = OutColor.ggg;
		}
		#else
			OutColor.rgb += FinalGrain * BackbufferQuantizationDithering;
		#endif
	}
	#endif

	#if DIM_ALPHA_CHANNEL
		OutColor.a = SceneColor.a;
	#endif

	return OutColor;
}

// pixel shader entry point
void MainPS(
	in noperspective float2 UV : TEXCOORD0,
	in noperspective float2 InVignette : TEXCOORD1,
	in noperspective float4 GrainUV : TEXCOORD2,
	in noperspective float2 ScreenPos : TEXCOORD3,
	in noperspective float2 FullViewUV : TEXCOORD4, 
	in FStereoPSInput StereoInput,
	float4 SvPosition : SV_POSITION,		// after all interpolators
	out float4 OutColor : SV_Target0
#if OUTPUT_LUMINANCE
	, out float OutLuminance: SV_Target1
#endif
	)
{
	float Luminance;
	float3 UVI = float3(UV.xy, GetEyeIndex(StereoInput));
	OutColor = TonemapCommonPS(UVI, InVignette, GrainUV, ScreenPos, FullViewUV, SvPosition, Luminance);
#if OUTPUT_LUMINANCE
	OutLuminance = Luminance;
#endif
}

#if COMPUTESHADER
RWTexture2D<float4> RWOutputTexture;
RWTexture2D<float> RWOutputLuminance;

[numthreads(THREADGROUP_SIZEX, THREADGROUP_SIZEY, 1)]
void MainCS(uint2 DispatchThreadId : SV_DispatchThreadID)
{
	float4 SvPosition = float4((float2)DispatchThreadId + 0.5f + Output_ViewportMin, 0.0f, 1.0f);
	float2 UV = ((float2)DispatchThreadId + 0.5f + Color_ViewportMin) * Color_ExtentInverse;

	if (IsComputeUVOutOfBounds(UV))
	{
		return;
	}

	float4 InScreenPos = float4(UV * float2(2, -2) - float2(1, -1), 0, 1);

	float2 Vignette;
	float4 GrainUV;
	float2 FullViewUV, ScreenPos;	
	TonemapCommonVS(InScreenPos, UV, Vignette, GrainUV, ScreenPos, FullViewUV);

	float Luminance;
	float4 OutColor = TonemapCommonPS(float3(UV.xy,0), Vignette, GrainUV, ScreenPos, FullViewUV, SvPosition, Luminance);

	uint2 PixelPos = DispatchThreadId + Output_ViewportMin;

	RWOutputTexture[PixelPos] = OutColor;
#if OUTPUT_LUMINANCE
	RWOutputLuminance[PixelPos] = Luminance;
#endif
}
#endif

#ifdef SUBPASS_MSAA_SAMPLES
	#if VULKAN_PROFILE
		#include "/Engine/Public/Platform/Vulkan/VulkanSubpassSupport.ush"
	#endif
#endif

half4 FetchAndResolveSceneColor(float2 UV, float ArrayIndex)
{
	half4 SceneColor = half4(1.0, 1.0, 1.0, 1.0);

#if VULKAN_PROFILE && SUBPASS_MSAA_SAMPLES > 0	
	#if SUBPASS_MSAA_SAMPLES == 8
		SceneColor = half4(VulkanSubpassFetch0(0) + VulkanSubpassFetch0(1) + VulkanSubpassFetch0(2) + VulkanSubpassFetch0(3) +
			VulkanSubpassFetch0(4) + VulkanSubpassFetch0(5) + VulkanSubpassFetch0(6) + VulkanSubpassFetch0(7)) * 0.125;
	#elif SUBPASS_MSAA_SAMPLES == 4
		SceneColor = half4(VulkanSubpassFetch0(0) + VulkanSubpassFetch0(1) + VulkanSubpassFetch0(2) + VulkanSubpassFetch0(3)) * 0.25;
	#elif SUBPASS_MSAA_SAMPLES == 2
		SceneColor = half4(VulkanSubpassFetch0(0) + VulkanSubpassFetch0(1)) * 0.5;
	#elif SUBPASS_MSAA_SAMPLES == 1
		SceneColor = half4(VulkanSubpassFetch0());
	#endif
#else
	#if MOBILE_MULTI_VIEW
		SceneColor = Texture2DArraySample(ColorTexture, ColorSampler, float3(UV.xy,ArrayIndex));
	#else
		SceneColor = Texture2DSample(ColorTexture, ColorSampler, UV);
	#endif
#endif
	return SceneColor;
}

void MobileCustomResolve_MainPS(
	in float4 SvPosition							: SV_POSITION, 
	in noperspective float2 UV						: TEXCOORD0,
	out				 float4 OutColor				: SV_Target0,
	in FStereoPSInput StereoInput
)
{
	StereoSetupPS(StereoInput);
	
	const float OneOverPreExposure = ResolvedView.OneOverPreExposure;

	half4 SceneColor = FetchAndResolveSceneColor(UV, GetEyeIndex(StereoInput));
	SceneColor.a = 1.0;

	half3 LinearColor = SceneColor.rgb * OneOverPreExposure;
	LinearColor *= ColorScale0.rgb; // SceneColorTint
	half3 DeviceColor = ColorLookupTable(LinearColor);

	OutColor.rgb = DeviceColor;
	OutColor.a = 1.0;
}
